!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Computes the tangent linear flux F and tangent linear advective inc

module tl_advective_and_flux_alg_mod

  use constants_mod,                   only: i_def, l_def
  use fem_constants_mod,               only: get_inverse_w3_mass_matrix
  use field_mod,                       only: field_type
  use fs_continuity_mod,               only: W2, W2h, W2v
  use log_mod,                         only: log_event, LOG_LEVEL_ERROR
  use operator_mod,                    only: operator_type
  use reconstruct_w3_field_alg_mod,    only: reconstruct_w3_field_alg
  use tl_reconstruct_w3_field_alg_mod, only: tl_reconstruct_w3_field_alg
  use transport_enumerated_types_mod,  only: direction_3d, &
                                             direction_h,  &
                                             direction_v
  use transport_metadata_mod,          only: transport_metadata_type
  use w3_advective_update_kernel_mod,  only: w3_advective_update_kernel_type
  use w3h_advective_update_kernel_mod, only: w3h_advective_update_kernel_type
  use w3v_advective_update_kernel_mod, only: w3v_advective_update_kernel_type

  implicit none

  private

  public :: tl_advective_and_flux_alg

contains

  !============================================================================!
  !> @brief Computes the tangent linear flux F and advective increment
  !> @details Compute the tangent linear mass flux and advective increment
  !> @param[in,out] mass_flux           ACTIVE: mass flux to compute
  !> @param[in,out] adv_inc             ACTIVE: advective increment to compute
  !> @param[in]     density             ACTIVE: W3 field to transport
  !> @param[in]     wind                ACTIVE: transporting wind field
  !> @param[in]     ls_density          PASSIVE: linearisation transported field
  !> @param[in]     ls_wind             PASSIVE: linearisation transporting wind
  !> @param[in]     direction           Direction of the transport
  !> @param[in]     transport_metadata  Contains transport configuration options
  !> @param[in]     final_rk_stage      Whether this is the last Runge-Kutta stage
  subroutine tl_advective_and_flux_alg(mass_flux, adv_inc, density, wind, &
                                       ls_density, ls_wind, direction,    &
                                       transport_metadata, final_rk_stage)

    implicit none

    type(field_type),              intent(in)    :: density, wind
    type(field_type),              intent(in)    :: ls_density, ls_wind
    type(field_type),              intent(inout) :: mass_flux, adv_inc
    integer(kind=i_def),           intent(in)    :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata
    logical(kind=l_def),           intent(in)    :: final_rk_stage

    ! Internal variables
    type(field_type)             :: w2_recon, ls_w2_recon
    type(field_type)             :: adv_inc_1, adv_inc_2
    type(field_type)             :: mass_flux_1, mass_flux_2
    type(operator_type), pointer :: m3_inv => null()

    ! Initialise temporary fields
    call w2_recon%initialise( wind%get_function_space() )
    call ls_w2_recon%initialise( wind%get_function_space() )
    call mass_flux_1%initialise( wind%get_function_space() )
    call mass_flux_2%initialise( wind%get_function_space() )
    call adv_inc_1%initialise( density%get_function_space() )
    call adv_inc_2%initialise( density%get_function_space() )

    m3_inv => get_inverse_w3_mass_matrix( density%get_mesh_id() )

    call invoke( setval_c(ls_w2_recon, 0.0_r_def), &
                 setval_c(w2_recon, 0.0_r_def) )

    ! Reconstruct W3 variables in W2
    call reconstruct_w3_field_alg(ls_w2_recon, ls_density, ls_wind,          &
                                  direction, transport_metadata, final_rk_stage)
    call tl_reconstruct_w3_field_alg(w2_recon, density, ls_density,          &
                                     ls_wind, direction, transport_metadata, &
                                     final_rk_stage)

    ! Obtain mass flux F = rho * u_ls + rho_ls * u
    call invoke( X_times_Y(mass_flux_1, w2_recon, ls_wind),     &
                 X_times_Y(mass_flux_2, ls_w2_recon, wind),     &
                 X_plus_Y(mass_flux, mass_flux_1, mass_flux_2), &
    ! Prepare to obtain advective increments
                 setval_c(adv_inc_1, 0.0_r_def),                &
                 setval_c(adv_inc_2, 0.0_r_def) )

    ! Different advective update kernel dependent on direction
    select case( direction )
    case ( direction_3d )
      call invoke( w3_advective_update_kernel_type(adv_inc_1, w2_recon,     &
                                                   ls_wind, m3_inv),        &
                   w3_advective_update_kernel_type(adv_inc_2, ls_w2_recon,  &
                                                   wind, m3_inv),           &
                   ! Obtain final increment by combining these two:
                   ! df' = ls_u.grad(f') + u'.grad(ls_f) )
                   X_plus_Y(adv_inc, adv_inc_1, adv_inc_2) )
    case ( direction_h )
      call invoke( w3h_advective_update_kernel_type(adv_inc_1, w2_recon,    &
                                                    ls_wind, m3_inv),       &
                   w3h_advective_update_kernel_type(adv_inc_2, ls_w2_recon, &
                                                    wind, m3_inv),          &
                   ! Obtain final increment by combining these two:
                   ! df' = ls_u.grad(f') + u'.grad(ls_f) )
                   X_plus_Y(adv_inc, adv_inc_1, adv_inc_2) )
    case ( direction_v )
      call invoke( w3v_advective_update_kernel_type(adv_inc_1, w2_recon,    &
                                                    ls_wind, m3_inv),       &
                   w3v_advective_update_kernel_type(adv_inc_2, ls_w2_recon, &
                                                    wind, m3_inv),          &
                   ! Obtain final increment by combining these two:
                   ! df' = ls_u.grad(f') + u'.grad(ls_f) )
                   X_plus_Y(adv_inc, adv_inc_1, adv_inc_2) )
    case default
      call log_event("T.L. advective update only on W2, W2h and W2v spaces", LOG_LEVEL_ERROR)
    end select

  end subroutine tl_advective_and_flux_alg

end module tl_advective_and_flux_alg_mod
