!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
module gencube_ps_mod_test

  use constants_mod,                  only: i_def, r_def, str_def, str_long
  use gencube_ps_mod,                 only: gencube_ps_type
  use global_mesh_map_collection_mod, only: global_mesh_map_collection_type
  use global_mesh_map_mod,            only: global_mesh_map_type

  use pFUnit_Mod

  implicit none

  private

  public :: test_C1, &
            test_C2, &
            test_C3

  @TestCase
  type, extends(TestCase), public :: gencube_ps_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_C1
    procedure test_C2
    procedure test_C3

  end type gencube_ps_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

  end subroutine tearDown


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_C1( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

    type(gencube_ps_type)  :: csgen
    integer(i_def)         :: nodes, edges, faces
    integer(i_def)         :: nodes_per_face, edges_per_face
    integer(i_def)         :: nodes_per_edge, max_faces_per_node

    character(str_def)  :: test_mesh_name
    character(str_def)  :: test_mesh_class
    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    character(str_long) :: test_constructor_inputs
    integer(i_def)      :: test_npanels
    integer(i_def)      :: test_edge_cells_x
    integer(i_def)      :: test_edge_cells_y
    integer(i_def)      :: test_nmaps

    character(str_def), allocatable :: test_maps_mesh_names(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_x(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_y(:)

    type(global_mesh_map_collection_type), pointer :: global_mesh_maps => null()
    type(global_mesh_map_type),            pointer :: global_mesh_map  => null()

    real(r_def), parameter :: eps = 1E-09_r_def

    integer(i_def) :: i,j,k,l,m

    integer(i_def), parameter :: edge_cells = 1
    integer(i_def), parameter :: nsmooth = 0
    integer(i_def), parameter :: npanels = 6
    integer(i_def), parameter :: nmaps = 0
    integer(i_def), parameter :: ncells = 6

    integer(i_def) :: faces_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: nodes_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: edges_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: nodes_on_edge(2, 2*6*edge_cells*edge_cells)
    real(r_def) :: coords(2, 6*edge_cells*edge_cells+2)
    real(r_def) :: face_coords(2, 6*edge_cells*edge_cells)

    csgen = gencube_ps_type( mesh_name, edge_cells, nsmooth )

    ! Test metadata retrieval
    call csgen%get_metadata( mesh_name          = test_mesh_name,          &
                             mesh_class         = test_mesh_class,         &
                             constructor_inputs = test_constructor_inputs, &
                             npanels            = test_npanels,            &
                             edge_cells_x       = test_edge_cells_x,       &
                             edge_cells_y       = test_edge_cells_y,       &
                             nmaps              = test_nmaps )


    @assertEqual( mesh_name, trim(test_mesh_name) )
    @assertEqual( 'sphere', trim(test_mesh_class) )
    @assertEqual( "edge_cells=1;smooth_passes=0", trim(test_constructor_inputs) )
    @assertEqual( npanels, test_npanels )
    @assertEqual( edge_cells, test_edge_cells_x )
    @assertEqual( edge_cells, test_edge_cells_y )
    @assertEqual( nmaps, test_nmaps )

    ! Generate the mesh and connectivity
    call csgen%generate()
    ! Retrieve calculated dimensions
    call csgen%get_dimensions(nodes, edges, faces, nodes_per_face, &
                              edges_per_face, nodes_per_edge)

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6*edge_cells*edge_cells+2, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 2*6*edge_cells*edge_cells, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 6*edge_cells*edge_cells, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")

    ! Retrieve mesh connectivity
    call csgen%get_connectivity(nodes_on_face, nodes_on_edge, &
                                edges_on_face, faces_on_face)

    ! Mesh has expected vertex values on certain faces
    @assertEqual( [  6, 5, 2, 1 ], nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( [  5, 7, 3, 2 ], nodes_on_face(:,2), "Incorrect vertex sequence on faces.")
    @assertEqual( [  8, 4, 3, 7 ], nodes_on_face(:,3), "Incorrect vertex sequence on faces.")
    @assertEqual( [  6, 1, 4, 8 ], nodes_on_face(:,4), "Incorrect vertex sequence on faces.")
    @assertEqual( [  1, 2, 3, 4 ], nodes_on_face(:,5), "Incorrect vertex sequence on faces.")
    @assertEqual( [  6, 8, 7, 5 ], nodes_on_face(:,6), "Incorrect vertex sequence on faces.")

    ! Mesh connectivity is complete
    @assertTrue(minval(faces_on_face, 2) /= 0, "Incomplete faces_on_face connectivity.")
    @assertTrue(minval(nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual( [ 4, 6, 2, 5 ], faces_on_face(:,1), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 1, 6, 3, 5 ], faces_on_face(:,2), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 6, 4, 5, 2 ], faces_on_face(:,3), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 6, 1, 5, 3 ], faces_on_face(:,4), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 4, 1, 2, 3 ], faces_on_face(:,5), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 1, 4, 3, 2 ], faces_on_face(:,6), "Incorrect faces_on_face connectivity.")

    @assertEqual( [  2,  3,  5,  1 ], edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual( [  5,  6,  8,  4 ], edges_on_face(:,2), "Incorrect edges_on_face connectivity.")
    @assertEqual( [  9, 11,  7,  8 ], edges_on_face(:,3), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 12,  2, 10, 11 ], edges_on_face(:,4), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 10,  1,  4,  7 ], edges_on_face(:,5), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 3,  12,  9,  6 ], edges_on_face(:,6), "Incorrect edges_on_face connectivity.")

    @assertEqual( [  1, 2 ], nodes_on_edge(:,1),  "Incorrect nodes_on_edge connectivity.")
    @assertEqual( [  6, 8 ], nodes_on_edge(:,12), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call csgen%get_coordinates( coords,             &
                                face_coords,        &
                                test_coord_units_x, &
                                test_coord_units_y )



    ! Node coordinates have expected values at specified points
    @assertTrue(abs(coords(1,1) - 315.0_r_def) < eps, "Incorrect x-coord, node 1.")
    @assertTrue(abs(coords(1,8) - 225.0_r_def) < eps, "Incorrect x-coord, node 8.")
    @assertTrue(abs(coords(2,1) - 35.264389682755_r_def) < eps, "Incorrect y-coord, node 1.")
    @assertTrue(abs(coords(2,8) + 35.264389682755_r_def) < eps, "Incorrect y-coord, node 8.")

    ! Check face co-ordinates for cells 1 and 20
    @assertTrue(abs(face_coords(1,1) - 360.0_r_def) < eps, "Incorrect x-coord, face 1.")
    @assertTrue(abs(face_coords(1,6) - 135.0_r_def) < eps, "Incorrect x-coord, face 8.")

    @assertTrue(abs(face_coords(2,1) -  0.0_r_def) < eps, "Incorrect y-coord, face 1.")
    @assertTrue(abs(face_coords(2,6) + 90.0_r_def) < eps, "Incorrect y-coord, face 8.")

    call csgen%clear()

    if ( allocated(test_maps_mesh_names)   ) deallocate(test_maps_mesh_names)
    if ( allocated(test_maps_edge_cells_x) ) deallocate(test_maps_edge_cells_x)
    if ( allocated(test_maps_edge_cells_y) ) deallocate(test_maps_edge_cells_y)
    nullify(global_mesh_maps)
    nullify(global_mesh_map)

  end subroutine test_C1

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_C2( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

    type(gencube_ps_type)  :: csgen
    integer(i_def)         :: nodes, edges, faces
    integer(i_def)         :: nodes_per_face, edges_per_face
    integer(i_def)         :: nodes_per_edge, max_faces_per_node

    character(str_def)  :: test_mesh_name
    character(str_def)  :: test_mesh_class
    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    character(str_long) :: test_constructor_inputs
    integer(i_def)      :: test_npanels
    integer(i_def)      :: test_edge_cells_x
    integer(i_def)      :: test_edge_cells_y
    integer(i_def)      :: test_nmaps

    character(str_def), allocatable :: test_maps_mesh_names(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_x(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_y(:)

    type(global_mesh_map_collection_type), pointer :: global_mesh_maps => null()
    type(global_mesh_map_type),            pointer :: global_mesh_map  => null()

    real(r_def), parameter :: eps = 1E-09_r_def

    integer(i_def) :: i,j,k,l,m

    integer(i_def), parameter :: edge_cells = 2
    integer(i_def), parameter :: nsmooth = 0
    integer(i_def), parameter :: npanels = 6
    integer(i_def), parameter :: nmaps = 0
    integer(i_def), parameter :: ncells = 24

    integer(i_def) :: faces_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: nodes_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: edges_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: nodes_on_edge(2, 2*6*edge_cells*edge_cells)
    real(r_def) :: coords(2, 6*edge_cells*edge_cells+2)
    real(r_def) :: face_coords(2, 6*edge_cells*edge_cells)

    csgen = gencube_ps_type( mesh_name, edge_cells, nsmooth )

    ! Test metadata retrieval
    call csgen%get_metadata( mesh_name          = test_mesh_name,          &
                             mesh_class         = test_mesh_class,         &
                             constructor_inputs = test_constructor_inputs, &
                             npanels            = test_npanels,            &
                             edge_cells_x       = test_edge_cells_x,       &
                             edge_cells_y       = test_edge_cells_y,       &
                             nmaps              = test_nmaps )


    @assertEqual( mesh_name, trim(test_mesh_name) )
    @assertEqual( 'sphere', trim(test_mesh_class) )
    @assertEqual( "edge_cells=2;smooth_passes=0", trim(test_constructor_inputs) )
    @assertEqual( npanels, test_npanels )
    @assertEqual( edge_cells, test_edge_cells_x )
    @assertEqual( edge_cells, test_edge_cells_y )
    @assertEqual( nmaps, test_nmaps )

    ! Generate the mesh and connectivity
    call csgen%generate()
    ! Retrieve calculated dimensions
    call csgen%get_dimensions(nodes, edges, faces, nodes_per_face, &
                              edges_per_face, nodes_per_edge)

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6*edge_cells*edge_cells+2, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 2*6*edge_cells*edge_cells, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 6*edge_cells*edge_cells, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")

    ! Retrieve mesh connectivity
    call csgen%get_connectivity(nodes_on_face, nodes_on_edge, &
                                edges_on_face, faces_on_face)

    ! Mesh has expected vertex values on certain faces
    @assertEqual( [  3,   4, 2, 1 ], nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( [  4,   7, 5, 2 ], nodes_on_face(:,2), "Incorrect vertex sequence on faces.")
    @assertEqual( [  22, 20, 4, 3 ], nodes_on_face(:,3), "Incorrect vertex sequence on faces.")
    @assertEqual( [  20, 18, 7, 4 ], nodes_on_face(:,4), "Incorrect vertex sequence on faces.")
    @assertEqual( [  7,   8, 6, 5 ], nodes_on_face(:,5), "Incorrect vertex sequence on faces.")
    @assertEqual( [  8,  11, 9, 6 ], nodes_on_face(:,6), "Incorrect vertex sequence on faces.")

    ! Mesh connectivity is complete
    @assertTrue(minval(faces_on_face, 2) /= 0, "Incomplete faces_on_face connectivity.")
    @assertTrue(minval(nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual( [ 14,  3, 2, 17 ], faces_on_face(:,1), "Incorrect faces_on_face connectivity.")
    @assertEqual( [  1,  4, 5, 19 ], faces_on_face(:,2), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 16, 23, 4,  1 ], faces_on_face(:,3), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 3,  21, 7,  2 ], faces_on_face(:,4), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 2,   7, 6, 19 ], faces_on_face(:,5), "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 5,   8, 9, 20 ], faces_on_face(:,6), "Incorrect faces_on_face connectivity.")

    @assertEqual( [  2,  3,  5,  1 ], edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual( [  5,  6, 12,  4 ], edges_on_face(:,2), "Incorrect edges_on_face connectivity.")
    @assertEqual( [  7,  8,  9,  3 ], edges_on_face(:,3), "Incorrect edges_on_face connectivity.")
    @assertEqual( [  9, 10, 17,  6 ], edges_on_face(:,4), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 12, 13, 15, 11 ], edges_on_face(:,5), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 15, 16, 22, 14 ], edges_on_face(:,6), "Incorrect edges_on_face connectivity.")

    ! Panel 3 is rotated right by 90 degrees (cicrcular shift of 1)
    @assertEqual( [ 23, 25, 21, 22 ], edges_on_face(:,9), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 30, 37, 26, 29 ], edges_on_face(:,12), "Incorrect edges_on_face connectivity.")

    ! Panel 4 is rotated right by 90 degrees (cicrcular shift of 1)
    @assertEqual( [ 36, 2, 34, 35 ], edges_on_face(:,14), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 40, 7, 36, 39 ], edges_on_face(:,16), "Incorrect edges_on_face connectivity.")

    ! Panel 5 is rotated left by 90 degrees (cicrcular shift of 1)
    @assertEqual( [ 34, 1,  41, 43 ], edges_on_face(:,17), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 42, 44, 14, 21 ], edges_on_face(:,20), "Incorrect edges_on_face connectivity.")

    ! Panel 6
    @assertEqual( [ 10, 45, 47, 18 ], edges_on_face(:,21), "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 48, 38, 30, 46 ], edges_on_face(:,24), "Incorrect edges_on_face connectivity.")

    @assertEqual( [  1, 2 ], nodes_on_edge(:,1),  "Incorrect nodes_on_edge connectivity.")
    @assertEqual( [  7, 5 ], nodes_on_edge(:,12), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call csgen%get_coordinates( coords,             &
                                face_coords,        &
                                test_coord_units_x, &
                                test_coord_units_y )

    ! Node coordinates have expected values at specified points
    @assertTrue(abs(coords(1,1) - 315.0_r_def) < eps, "Incorrect longitude, node 1.")
    @assertTrue(abs(coords(1,8) -  90.0_r_def) < eps, "Incorrect latitude,  node 8.")
    @assertTrue(abs(coords(2,1) -  35.264389682755_r_def) < eps, "Incorrect latitude, node 1.")
    @assertTrue(abs(coords(2,8) + 0.0_r_def)   < eps, "Incorrect latitude, node 8.")

    ! Check face co-ordinates for cells 1 and 6
    @assertTrue(abs(face_coords(1,1) - 336.763262421756_r_def) < eps, "Incorrect longitude, cell 1.")
    @assertTrue(abs(face_coords(1,6) - 113.236737578244_r_def) < eps, "Incorrect longitude, cell 6.")

    @assertTrue(abs(face_coords(2,1) - 21.5307797199715_r_def) < eps, "Incorrect latitude, cell 1.")
    @assertTrue(abs(face_coords(2,6) - 21.5307797199715_r_def) < eps, "Incorrect latitude, cell 6.")

    call csgen%clear()

    if ( allocated(test_maps_mesh_names)   ) deallocate(test_maps_mesh_names)
    if ( allocated(test_maps_edge_cells_x) ) deallocate(test_maps_edge_cells_x)
    if ( allocated(test_maps_edge_cells_y) ) deallocate(test_maps_edge_cells_y)
    nullify(global_mesh_maps)
    nullify(global_mesh_map)

  end subroutine test_C2

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_C3( this )

    implicit none

    class(gencube_ps_test_type), intent(inout) :: this

    type(gencube_ps_type)  :: csgen
    integer(i_def)         :: nodes, edges, faces
    integer(i_def)         :: nodes_per_face, edges_per_face
    integer(i_def)         :: nodes_per_edge, max_faces_per_node

    character(str_def)  :: test_mesh_name
    character(str_def)  :: test_mesh_class
    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    character(str_long) :: test_constructor_inputs
    integer(i_def)      :: test_npanels
    integer(i_def)      :: test_edge_cells_x
    integer(i_def)      :: test_edge_cells_y
    integer(i_def)      :: test_nmaps

    character(str_def), allocatable :: test_maps_mesh_names(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_x(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_y(:)

    type(global_mesh_map_collection_type), pointer :: global_mesh_maps => null()
    type(global_mesh_map_type),            pointer :: global_mesh_map  => null()

    real(r_def), parameter :: eps = 1E-09_r_def

    integer(i_def) :: i,j,k,l,m



    integer(i_def), parameter :: edge_cells = 3
    integer(i_def), parameter :: nsmooth = 1
    integer(i_def), parameter :: npanels = 6
    integer(i_def), parameter :: nmaps = 1
    integer(i_def), parameter :: ncells = 54
    character(str_def), parameter :: target_mesh_names(nmaps) = ['unit_test_target']
    integer(i_def),     parameter :: target_edge_cells(nmaps) = [6]

    integer(i_def) :: faces_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: nodes_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: edges_on_face(4, 6*edge_cells*edge_cells)
    integer(i_def) :: nodes_on_edge(2, 2*6*edge_cells*edge_cells)
    real(r_def) :: coords(2, 6*edge_cells*edge_cells+2)
    real(r_def) :: face_coords(2, 6*edge_cells*edge_cells)

    csgen = gencube_ps_type( mesh_name, edge_cells, nsmooth,      &
                             target_mesh_names=target_mesh_names, &
                             target_edge_cells=target_edge_cells )

    ! Test metadata retrieval
    call csgen%get_metadata( mesh_name          = test_mesh_name,          &
                             mesh_class         = test_mesh_class,         &
                             constructor_inputs = test_constructor_inputs, &
                             npanels            = test_npanels,            &
                             edge_cells_x       = test_edge_cells_x,       &
                             edge_cells_y       = test_edge_cells_y,       &
                             nmaps              = test_nmaps,              &
                             maps_mesh_names    = test_maps_mesh_names,    &
                             maps_edge_cells_x  = test_maps_edge_cells_x,  &
                             maps_edge_cells_y  = test_maps_edge_cells_y )

    @assertEqual( mesh_name, trim(test_mesh_name) )
    @assertEqual( 'sphere', trim(test_mesh_class) )
    @assertEqual( "edge_cells=3;smooth_passes=1;target_mesh_names=['unit_test_target'];target_edge_cells=[6]", trim(test_constructor_inputs) )
    @assertEqual( npanels, test_npanels )
    @assertEqual( edge_cells, test_edge_cells_x )
    @assertEqual( edge_cells, test_edge_cells_y )
    @assertEqual( nmaps, test_nmaps )
    @assertEqual( trim(target_mesh_names(1)), trim(test_maps_mesh_names(1)) )
    @assertEqual( target_edge_cells, test_maps_edge_cells_x )
    @assertEqual( target_edge_cells, test_maps_edge_cells_y )
    @assertEqual( nmaps, size(test_maps_mesh_names   ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_x ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_y ) )

    ! Generate the mesh and connectivity
    call csgen%generate()
    ! Retrieve calculated dimensions
    call csgen%get_dimensions(nodes, edges, faces, nodes_per_face, &
                              edges_per_face, nodes_per_edge)

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6*edge_cells*edge_cells+2, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 2*6*edge_cells*edge_cells, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 6*edge_cells*edge_cells, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")

    ! Retrieve mesh connectivity
    call csgen%get_connectivity(nodes_on_face, nodes_on_edge, &
                                edges_on_face, faces_on_face)

    ! Mesh has expected vertex values on certain faces
    @assertEqual( [  4, 5, 2, 1 ], nodes_on_face(:,1),  "Incorrect vertex sequence on faces.")
    @assertEqual( [ 24,21,20,23 ], nodes_on_face(:,20), "Incorrect vertex sequence on faces.")

    ! Mesh connectivity is complete
    @assertTrue(minval(faces_on_face, 2) /= 0, "Incomplete faces_on_face connectivity.")
    @assertTrue(minval(nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual( [ 30, 4, 2,37 ], faces_on_face(:,1),  "Incorrect faces_on_face connectivity.")
    @assertEqual( [ 10,14,12,44 ], faces_on_face(:,11), "Incorrect faces_on_face connectivity.")

    @assertEqual( [  2, 3, 5, 1 ], edges_on_face(:,1),  "Incorrect edges_on_face connectivity.")
    @assertEqual( [ 48,50,46,47 ], edges_on_face(:,20), "Incorrect edges_on_face connectivity.")

    @assertEqual( [  1, 2 ], nodes_on_edge(:,1),  "Incorrect nodes_on_edge connectivity.")
    @assertEqual( [ 43,42 ], nodes_on_edge(:,40), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call csgen%get_coordinates( coords,             &
                                face_coords,        &
                                test_coord_units_x, &
                                test_coord_units_y )



    ! Node coordinates have expected values at specified points
    @assertTrue(abs(coords(1,1)  - 315.0000000000001137_r_def) < eps, "Incorrect x-coord, node 1.")
    @assertTrue(abs(coords(2,1)  -  35.2643896827546399_r_def) < eps, "Incorrect y-coord, node 1.")
    @assertTrue(abs(coords(1,20) - 160.7237414026762394_r_def) < eps, "Incorrect x-coord, node 20.")
    @assertTrue(abs(coords(2,20) -  43.3480768096655993_r_def) < eps, "Incorrect y-coord, node 20.")

    ! Check face co-ordinates for cells 1 and 20
    @assertTrue(abs(face_coords(1,1)  - 328.6231683398669929375_r_def) < eps, "Incorrect x-coord, face 1.")
    @assertTrue(abs(face_coords(2,1)  -  27.5043902958763375466_r_def) < eps, "Incorrect y-coord, face 1.")
    @assertTrue(abs(face_coords(1,20) - 179.9999999999999715783_r_def) < eps, "Incorrect x-coord, face 20.")
    @assertTrue(abs(face_coords(2,20) -  30.1569744318065886546_r_def) < eps, "Incorrect y-coord, face 20.")

    @assertTrue( trim(test_coord_units_x) == 'degrees_east')
    @assertTrue( trim(test_coord_units_y) == 'degrees_north')


    ! Retrieve global mesh maps
    nullify(global_mesh_maps)
    global_mesh_maps => csgen%get_global_mesh_maps()
    @assertAssociated( global_mesh_maps )

    ! Although no actual global mesh maps have written to file maps have been created
    ! for global meshes in the order they are virtually listed,
    ! i.e. mesh "unit_test", id=1
    !      mesh "unit_test_target", id=2
    nullify(global_mesh_map)
    global_mesh_map  => global_mesh_maps%get_global_mesh_map(1,2)

    @assertAssociated( global_mesh_map )
    @assertEqual( ncells, global_mesh_map%get_nsource_cells() )
    @assertEqual( 4,  global_mesh_map%get_ntarget_cells_per_source_cell() )
    @assertEqual( 1,  global_mesh_map%get_source_id() )
    @assertEqual( 2,  global_mesh_map%get_target_id() )

    call csgen%clear()

    if ( allocated(test_maps_mesh_names)   ) deallocate(test_maps_mesh_names)
    if ( allocated(test_maps_edge_cells_x) ) deallocate(test_maps_edge_cells_x)
    if ( allocated(test_maps_edge_cells_y) ) deallocate(test_maps_edge_cells_y)
    nullify(global_mesh_maps)
    nullify(global_mesh_map)

  end subroutine test_C3

end module gencube_ps_mod_test
